# Random Number Generation

## Witnet RNG request
The Witnet RNG request shares the same structure as a standard request with the 3 stages (retrieval, aggregation and 
tally) and it will be solved by the same witnesses that are currently working in the Witnet mainnet.

### Retrieval
As a source for RNG requests, we specify a new `RADType` called `Rng`. This new source will trigger the creation of a
random vector of 32 bytes, instead of reading data from an API source. The rest of fields are unnecessary: the `url` 
field must be empty and the `script` field will be ignored, so we can specify the CBOR code for an empty array 
(`[128]`). A single source is used in the retrieval section of this kind of requests.

```rust
"retrieve":[
    {
        "kind":"RNG",
        "url":"",
        "script":[128]
    }
]
```

### Aggregation
Aggregation is not necessary due to the fact that RNG requests have only one retrieval. To unwrap the `RadonArray` 
into a single element, we will use the `Mode` as a `RadonReducer` without filters.

```rust
"aggregate":{
    "filters": [], 
    "reducer": 2,
}
```

### Tally
For the tally stage, a new `RadonReducer` is required, `HashConcatenate`. This reducer takes the `RadonBytes` revealed 
by the witnesses, concatenates them into a single vector of bytes and hash them with SHA256. In the same way, as in the 
aggregation stage, no filters are required.

```rust
"tally":{
    "filters": [], 
    "reducer": 11,
}
```

## Conclusions
The random numbers (actually, random bytes) generated by the Witnet protocol are the result of applying a hash 
function on a crowdsourced seed coming from the random bytes provided by several different witnesses, as selected 
randomly by the Witnet protocol. That is, the randomness property of these is powered by the decentralized nature 
of the Witnet network.


